## Overview

Floating point numbers in Go represent real numbers with a fractional component. They are used for precision calculations, scientific computations, and scenarios where decimal points are essential.

<br>

---

<br>

## Floating Point Types in Go

Go provides two floating point types based on precision:

| Type      | Size (in bits) | Precision (Decimal Digits) | Range                      |
| --------- | -------------- | -------------------------- | -------------------------- |
| `float32` | 32             | ~7 digits                  | ±1.18×10⁻³⁸ to ±3.4×10³⁸   |
| `float64` | 64             | ~15 digits                 | ±2.23×10⁻³⁰⁸ to ±1.8×10³⁰⁸ |

### Default Type

- Floating point literals are of type `float64` by default.
- Example:

```go
var x = 3.14 // x is float64
```

### Declaration

- **Using `var`:**

```go
var pi float32 = 3.14
var e float64 = 2.718
```

- **Short Declaration:**

```go
pi := 3.14
```

<br>

---

<br>

## Operations on Floating Point Numbers

### Arithmetic Operations

Floating point numbers support basic arithmetic operations:

- **Addition:**

```go
sum := a + b
```

- **Subtraction:**

```go
diff := a - b
```

- **Multiplication:**

```go
product := a * b
```

- **Division:**

```go
quotient := a / b
```

<br>

### Comparison Operators

Floating point numbers can be compared using:

- `==`, `!=`, `<`, `>`, `<=`, `>=`
- Example:

```go
if a > b {
    fmt.Println("a is greater than b")
}
```

<br>

### Special Floating Point Values

- **Infinity (`+Inf`, `-Inf`)**:

```go
import "math"

func main() {
    fmt.Println(1.0 / 0.0) // +Inf
    fmt.Println(-1.0 / 0.0) // -Inf
}
```

- **NaN (Not a Number):**

- Generated by invalid operations such as `0.0 / 0.0`.

```go
fmt.Println(0.0 / 0.0) // NaN
```

- Use `math.IsInf` and `math.IsNaN` to check:

```go
if math.IsNaN(result) {
    fmt.Println("Result is NaN")
}
```

<br>

---

<br>

## Precision and Rounding

### Floating Point Precision

- Floating point numbers may lose precision in operations:

```go
fmt.Println(0.1 + 0.2) // Outputs 0.30000000000000004
```

- Always consider potential errors in equality checks:

```go
const epsilon = 1e-9
if math.Abs(a-b) < epsilon {
    fmt.Println("a and b are approximately equal")
}
```

### Rounding

Use `math` package functions:

- `math.Round`: Rounds to the nearest integer.

```go
fmt.Println(math.Round(2.5)) // 3
```

- `math.Floor`: Rounds down to the nearest integer.

```go
fmt.Println(math.Floor(2.8)) // 2
```

- `math.Ceil`: Rounds up to the nearest integer.

```go
fmt.Println(math.Ceil(2.3)) // 3
```

<br>

---

<br>

## Conversions

### Between Floating Point Types

Convert explicitly to avoid type mismatches:

```go
var a float32 = 3.14
var b float64 = float64(a)
```

### Between Integer and Floating Point

- Integer to float:

```go
var i int = 42
var f float64 = float64(i)
```

- Float to integer (truncates the fractional part):

```go
var x float64 = 3.99
var y int = int(x) // y = 3
```

<br>

---

<br>

## Common Math Functions

The `math` package provides many useful functions for floating point numbers:

| Function         | Description                     | Example                         |
| ---------------- | ------------------------------- | ------------------------------- |
| `math.Abs(x)`    | Absolute value                  | `math.Abs(-3.14)` → `3.14`      |
| `math.Sqrt(x)`   | Square root                     | `math.Sqrt(16)` → `4`           |
| `math.Pow(x, y)` | x raised to the power y         | `math.Pow(2, 3)` → `8`          |
| `math.Sin(x)`    | Sine of x (in radians)          | `math.Sin(math.Pi/2)` → `1`     |
| `math.Cos(x)`    | Cosine of x (in radians)        | `math.Cos(0)` → `1`             |
| `math.Log(x)`    | Natural logarithm (base e) of x | `math.Log(math.E)` → `1`        |
| `math.Exp(x)`    | e raised to the power x         | `math.Exp(1)` → `2.71828182846` |

<br>

---

<br>

## Floating Point Gotchas

### Comparing Floats

- Avoid direct comparisons due to precision issues:

```go
if math.Abs(a-b) < epsilon {
    fmt.Println("Approximately equal")
}
```

### Overflow and Underflow

- Large values may overflow:

```go
fmt.Println(math.Pow(10, 400)) // +Inf
```

- Small values may underflow to `0`.

<br>

---

<br>

## Best Practices

**Use `float64` for Precision**:

- Always prefer `float64` unless memory is a constraint.

**Avoid Equality Comparisons**:

- Use a small threshold (`epsilon`) for approximate comparisons.

**Use Explicit Conversions**:

- Convert between integers and floats explicitly to avoid unintended truncations.

**Rely on Math Functions**:

- Utilize the `math` package for complex calculations and consistent behavior.
